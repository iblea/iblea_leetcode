class Solution {
public:
    int numDecodings(string s) {

        // 61 -> 1 (6,1)
        // 11 -> 2 (1,1) (11)
        // 17 -> 2 (1,7) (17)
        // 171 -> 2 (1,7,1) (17,1)
        // 1717 -> 4 (1,7,1,7) (17,1,7) (1,7,17) (17,17)
        // 117 -> 3 (1,1,7) (11,7) (1,17)
        // 1176 -> 3 (1,1,7,6) (11,7,6) (1,17,6)
        // 11768 -> 3 (1,1,7,6,8) (11,7,6,8) (1,17,6,8)
        // 1171 -> 3 (1,1,7,1) (11,7,1) (1,17,1)
        // 11711 -> 5 (1,1,7,1,1) (11,7,1,1) (11,7,11) (1,17,1,1) (1,17,11)
        // 1 -> 1 (1)
        // 11 -> 2 (1,1) (11)
        // 111 -> 3 (1,1,1) (11,1) (1,11)
        // 1111 -> 5 (1,1,1,1) (11,1,1) (1,11,1) (1,1,11) (11,11)
        // 11111 -> 8 (1,1,1,1,1) (11,1,1,1) (1,11,1,1) (1,1,11,1) (1,1,1,11) (11,11,1) (11,1,11) (1,11,11)
        // 111111 -> 13 (1,1,1,1,1,1) (11,1,1,1,1) (1,11,1,1,1) (1,1,11,1,1) (1,1,1,11,1) (1,1,1,1,11) (11,11,1,1) (11,1,11,1) (11,1,1,11) (1,11,11,1) (1,11,1,11) (1,1,11,11), (11,11,11)


        // 1,2가 연속되어 나오면 피보나치(n) 만큼 가짓수가 많아진다.
        // 조건1: 1인경우 0~9, 2인경우 다음 숫자가 0~6 까지 피보나치 수를 더할 수 있다.
        // 1,2가 지속 나올 경우 피보나치를 더하고, 기타 숫자가 나올 경우 조건1을 체크하고 피보나치 수를 더할 수 있는 숫자이면 더한 뒤, 가짓수에 추가, 그렇지 못하면 지금까지 구한 숫자를 더한다. ex: (229) 는 2,29 로 디코딩이 불가능함.

        if (s[0] == '0') {
            return 0;
        }

        int n = s.length();
        vector<int> dp(n + 1, 1);
        int count = 1;

        vector<string> divide;
        // 가능한 조각으로 먼저 나눈 뒤에 조각을 하나씩 더해가며 디코딩 가능한지 확인 (0 때문에 디코딩이 가능한 경우인지 확인해야 한다.)
        for (int i = 0; i < n; i++) {
            if (s[i] != '0') {
                divide.push_back(string(1, s[i]));
                continue;
            }
            if (s[i] == '0') {
                int div_size = divide.size() - 1;
                divide[div_size] += s[i];
                if (divide[div_size] == "10" || divide[div_size] == "20") {
                    continue;
                } else {
                    return 0;
                }
            }
        }

        int div_size = divide.size();
        for (int i = 1; i < div_size; i++) {
            if (divide[i-1] == "1") {
                if (divide[i].length() > 1) {
                    // 10, 20
                    if (dp[i] > 1) {
                        count *= dp[i];
                    }
                    continue;
                } else if (divide[i] == "1" || divide[i] == "2") {
                    // 1,2
                    dp[i + 1] = dp[i] == 1 ? 2 : dp[i-1] + dp[i];
                    if (i == div_size - 1) {
                        count *= dp[i+1];
                    }
                    continue;
                } else {
                    // 3,4,5,6,7,8,9
                    dp[i + 1] = dp[i] == 1 ? 2 : dp[i-1] + dp[i];
                    count *= dp[i+1];
                    continue;
                }
            }
            if (divide[i-1] == "2") {
                if (divide[i].length() > 1 || divide[i] > "6") {
                    // 10,20,7,8,9
                    if (dp[i] > 1) {
                        count *= dp[i];
                    }
                    continue;
                } else if ((divide[i] == "1" || divide[i] == "2")) {
                    // 1,2
                    dp[i + 1] = dp[i] == 1 ? 2 : dp[i-1] + dp[i];
                    if (i == div_size - 1) {
                        count *= dp[i+1];
                    }
                } else {
                    // 3,4,5,6
                    dp[i + 1] = dp[i] == 1 ? 2 : dp[i-1] + dp[i];
                    count *= dp[i+1];
                }
            }
            continue;
        }

        return count == 0 ? 1 : count;
    }
};